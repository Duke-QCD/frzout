# -*- coding: utf-8 -*-

import glob
import inspect
import os
from contextlib import contextmanager

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate
from scipy import special
from scipy import stats
from sphinx.util import console

import frzout


sections = []


def section(function):
    sections.append(function)
    return function


def main(app):
    srcdir = app.builder.srcdir
    testsdir = os.path.join(app.config.html_static_path[0], 'tests')

    app.info(console.bold('generating test plots...'), nonl=True)

    # skip if all generated plot files are newer than this file
    plot_files = glob.glob(os.path.join(srcdir, testsdir, '*', '*.png'))
    if plot_files and all(
            os.path.getmtime(f) > os.path.getmtime(__file__)
            for f in plot_files
    ):
        app.info(' all up to date')
        return

    app.info()

    with open(os.path.join(srcdir, 'tests.rst'), 'w') as rst_file:
        rst_file.write(
            'Tests\n'
            '=====\n'
            'This page is automatically generated by '
            '`{basename} <https://github.com/{github_user}/{github_repo}'
            '/blob/master/doc/{basename}>`_ in the frzout repository.\n\n'
            'Each plot compares observables computed from the sampler '
            '(colored lines) to expected results (dark grey lines).\n'
            .format(
                basename=os.path.basename(__file__),
                **app.config.html_context
            )
        )

        for section in sections:
            title = section.__name__.replace('_', ' ').capitalize()
            app.info('  ' + title)
            rst_file.write(
                '\n{}\n{}\n{}\n'
                .format(title, '-'*len(title), inspect.getdoc(section))
            )

            reldir = os.path.join(testsdir, section.__name__)
            absdir = os.path.join(srcdir, reldir)
            os.makedirs(absdir, exist_ok=True)

            @contextmanager
            def axes(subsec=None, caption=None):
                if subsec:
                    app.info('    ' + subsec)
                    rst_file.write(
                        '\n{}\n{}'.format(subsec, '~'*len(subsec))
                    )
                if caption:
                    rst_file.write('\n{}\n'.format(caption))
                filename = '{:03d}.png'.format(axes.n)
                rst_file.write(
                    '\n.. image:: {0}\n   :target: {0}\n'
                    .format(os.path.join(reldir, filename))
                )
                yield plt.axes()
                plt.savefig(os.path.join(absdir, filename))
                plt.close()
                axes.n += 1

            axes.n = 0

            section(axes)


def setup(app):
    app.connect('builder-inited', main)


default_color = '#404040'
color_cycle = [
    getattr(plt.cm, c)(.8) for c in
    ['Blues', 'Greens', 'Oranges', 'Purples']
]
font_size = 16

plt.rcdefaults()
plt.rcParams.update({
    'figure.figsize': (10, 6.18),
    'figure.dpi': 200,
    'figure.autolayout': True,
    'font.family': ['Lato'],
    'font.size': font_size,
    'legend.fontsize': font_size,
    'axes.labelsize': font_size,
    'axes.titlesize': font_size,
    'xtick.labelsize': font_size - 2,
    'ytick.labelsize': font_size - 2,
    'lines.linewidth': 1.25,
    'lines.markeredgewidth': .1,
    'patch.linewidth': 1.25,
    'axes.prop_cycle': plt.cycler('color', color_cycle),
    'axes.grid': True,
    'axes.axisbelow': True,
    'axes.facecolor': '#eaeaf2',
    'axes.linewidth': 0,
    'grid.linestyle': '-',
    'grid.linewidth': 1,
    'grid.color': '#fcfcfc',
    'savefig.facecolor': '#fcfcfc',
    'xtick.major.size': 0,
    'ytick.major.size': 0,
    'xtick.minor.size': 0,
    'ytick.minor.size': 0,
    'xtick.major.pad': 7,
    'ytick.major.pad': 7,
    'text.color': default_color,
    'axes.edgecolor': default_color,
    'axes.labelcolor': default_color,
    'xtick.color': default_color,
    'ytick.color': default_color,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
})


id_parts = [
    (211, r'$\pi^\pm$'),
    (321, r'$K^\pm$'),
    (2212, r'$p \bar p$'),
]

hbarc = 0.1973269788


@section
def stationary_box(axes):
    """
    A single boost-invariant volume element with zero flow velocity.
    This is a rudimentary test case with easily-calculated observables.

    """
    volume = 3000.
    tau = 1.
    T = .15
    ymax = np.random.uniform(.5, .8)

    info = [frzout.species_dict[i] for (i, _) in id_parts]
    m = np.array([i['mass'] for i in info])
    g = np.array([i['degen'] for i in info])
    sign = np.array([-1 if i['boson'] else 1 for i in info])

    n = np.arange(1, 10)
    densities = g * m*m*T / (2*np.pi**2*hbarc**3) * (
        np.power.outer(-sign, n-1)/n *
        special.kn(2, np.outer(m, n)/T)
    ).sum(axis=1)
    yields = 2*ymax * volume * densities

    x = np.array([[tau, 0, 0]])
    sigma = np.array([[volume/tau, 0, 0]])
    v = np.zeros((1, 2))

    sampler = frzout.Sampler(x, sigma, v, T, ymax=ymax)

    nsamples = 1000
    samples = list(sampler.iter_samples(nsamples))
    parts = np.concatenate(samples).view(np.recarray)

    abs_ID = np.abs(parts.ID)
    E, px, py, pz = parts.p.T

    with axes(
            'Multiplicity distributions',
            'These are histograms of particle counts from many oversamples. '
            'Production of each species should be Poissonian:'
    ) as ax:
        for (i, label), N in zip(id_parts, yields):
            dist = stats.poisson(N)
            x = np.arange(*dist.ppf([.001, .999]).astype(int))
            ax.plot(x, dist.pmf(x), color=default_color)
            ax.hist([np.count_nonzero(s.ID == i) for s in samples],
                    bins=20, normed=True, histtype='step',
                    label=label.replace(r'\pm', '+').replace(r' \bar p', ''))

        ax.set_xlabel('Number of particles')
        ax.set_ylabel('Probability')
        ax.set_yticklabels([])
        ax.legend()

    with axes(caption=(
            'Overall particle production (all species) '
            'should also be Poissonian:'
    )) as ax:
        N = np.array([s.size for s in samples])
        dist = stats.poisson(sampler.navg)
        x = np.arange(*dist.ppf([.001, .999]).astype(int))
        ax.plot(x, dist.pmf(x), color=default_color)
        ax.hist(N, bins=30, normed=True,
                histtype='step', color=color_cycle[-1])
        ax.set_xlabel('Number of particles')
        ax.set_ylabel('Probability')
        ax.set_yticklabels([])

    with axes('Transverse momentum', 'Spectra are perfectly thermal:') as ax:
        pT = np.sqrt(px*px + py*py)
        pT_plot = np.linspace(0, 3, 1000)
        for k, (i, label) in enumerate(id_parts):
            mT = np.sqrt(frzout.species_dict[i]['mass']**2 + pT_plot**2)
            dN_dpT = 2*(
                volume * frzout.species_dict[i]['degen'] * (
                    np.outer(
                        2*mT,
                        (1 if frzout.species_dict[i]['boson'] else -1)**(n-1)
                    ) * special.k1(np.outer(mT, n)/T)
                ).sum(axis=1) / (2*np.pi*hbarc)**3
            )
            scale = 10**(-2*k)
            ax.plot(pT_plot, dN_dpT*scale, color=default_color)
            pT_ = pT[abs_ID == i]
            bins = np.linspace(0, pT_.max(), 50)
            ax.hist(
                pT_, bins=bins,
                weights=bins.size/bins.ptp()*scale/(
                    2*np.pi*pT_*2*ymax*nsamples),
                histtype='step', log=True,
                label=r'{} $({{\times}}10^{{{:d}}})$'.format(label, -2*k)
            )

        ax.set_xlabel('$p_T\ [\mathrm{GeV}]$')
        ax.set_ylabel('$1/2\pi p_T \: dN/dp_T\,dy\ [\mathrm{GeV}^{-2}]$')
        ax.yaxis.get_major_locator().base(100)
        ax.legend()

    with axes('Rapidity', '`dN/dy` should be flat:') as ax:
        y = .5*np.log((E + pz)/(E - pz))
        nbins = 50
        for (i, label), N in zip(id_parts, yields):
            ax.plot([-ymax, ymax], [2*N]*2, color=default_color)
            y_ = y[abs_ID == i]
            ax.hist(y_, bins=nbins, weights=np.full_like(y_, nbins/nsamples),
                    histtype='step', log=True, label=label)

        ax.set_xlabel('$y$')
        ax.set_ylabel('$dN/dy$')
        ax.legend(loc='lower center', ncol=len(id_parts))

    with axes('Azimuthal angle', '`dN/d\phi` should be flat:') as ax:
        phi = np.arctan2(py, px)
        nbins = 50
        for (i, label), N in zip(id_parts, yields):
            ax.plot([-np.pi, np.pi], [2*N]*2, color=default_color)
            phi_ = phi[abs_ID == i]
            ax.hist(phi_, bins=nbins,
                    weights=np.full_like(phi_, nbins/nsamples),
                    histtype='step', log=True, label=label)

        ax.set_xlim(-np.pi, np.pi)
        ax.set_xlabel('$\phi$')
        ax.set_ylabel('$dN/d\phi$')
        ax.legend(loc='lower center', ncol=len(id_parts))


@section
def moving_box(axes):
    """
    A single 3D volume element with nonzero flow velocity (but still zero
    normal vector to avoid negative contributions).  Histograms of sampled (x,
    y, z) momenta are compared to distributions computed by numerically
    integrating the distribution functions.

    """
    T = .15
    x = np.array([[1, 0, 0, 0]], dtype=float)

    for ID, name in id_parts:
        info = frzout.species_dict[ID]
        m = info['mass']
        g = info['degen']
        sign = -1 if info['boson'] else 1

        hrg = frzout.HRG(T, species=[ID])

        v = np.atleast_2d([np.random.uniform(-i, i) for i in [.5, .5, .7]])
        gamma = 1/np.sqrt(1 - (v*v).sum())
        ux, uy, uz = gamma*v.ravel()

        volume = 1e6/hrg.density()
        sigma = np.array([[volume, 0, 0, 0]])
        surface = frzout.Surface(x, sigma, v)

        parts = frzout.sample(surface, hrg)
        psamples = parts['p'].T[1:]

        # 3D lattice of momentum points
        P = [np.linspace(1.05*p.min(), 1.05*p.max(), 100) for p in psamples]
        Px, Py, Pz = np.meshgrid(*P, indexing='ij')
        dp = [p.ptp()/(p.size - 1) for p in P]

        # evaluate distribution function on lattice
        E = np.sqrt(m*m + Px*Px + Py*Py + Pz*Pz)
        f = 1/(np.exp((E*gamma - Px*ux - Py*uy - Pz*uz)/T) + sign)
        f *= 2*g/(2*np.pi*hbarc)**3

        with axes(name.replace('$', '`') + ' momentum') as ax:
            ax.set_yscale('log')

            ax.annotate(
                '\n'.join([
                    '$v_{} = {:+.4f}$'.format(*i)
                    for i in zip(['x', 'y', 'z'], v.flat)
                ]),
                (.04, .95), xycoords='axes fraction', ha='left', va='top'
            )

            nbins = 50
            for i, (p, c) in enumerate(zip(psamples, ['x', 'y', 'z'])):
                ax.hist(
                    p, bins=nbins,
                    weights=np.full_like(p, nbins/p.ptp()/volume),
                    histtype='step', label='$p_{}$'.format(c)
                )
                j, k = set(range(3)) - {i}
                # evaluate f along axis i by integrating out axes (j, k)
                ax.plot(
                    P[i], dp[j] * dp[k] * f.sum(axis=(j, k)),
                    color=default_color
                )

            ax.set_xlabel('$p\ [\mathrm{GeV}]$')
            ax.set_ylabel('$dN/dp\ [\mathrm{GeV}^{-1}]$')
            ax.legend()


@section
def resonance_mass_distributions(axes):
    """
    Verification of mass disributions for several resonance species.  Grey
    dashed lines are the Breit-Wigner distributions with mass-dependent width,
    grey solid lines are the same distributions with momentum integrated out,
    and colored lines are histograms of the sampled masses.

    """
    with axes() as ax:
        T = .15

        for ID, name in [
                (213, r'$\rho(770)$'),
                (2214, r'$\Delta(1232)$'),
                (22212, r'$N(1535)$'),
        ]:
            info = frzout.species_dict[ID]
            m0 = info['mass']
            w0 = info['width']
            m_min, m_max = info['mass_range']
            sign = -1 if info['boson'] else 1

            def bw(m):
                w = w0*np.sqrt((m - m_min)/(m0 - m_min))
                return w/((m - m0)**2 + w*w/4)

            def f(p, m):
                return p*p / (np.exp(np.sqrt(p*p + m*m)/T) + sign)

            m = np.linspace(m_min, m_max, 200)

            ax.plot(m, bw(m)/integrate.quad(bw, m_min, m_max)[0],
                    color=default_color, ls='dashed')

            bwf = np.array([
                integrate.quad(lambda p: bw(m_)*f(p, m_), 0, 5)[0] for m_ in m
            ]) / integrate.dblquad(
                lambda m_, p: bw(m_)*f(p, m_),
                0, 5, lambda _: m_min, lambda _: m_max
            )[0]

            ax.plot(m, bwf, color=default_color)

            hrg = frzout.HRG(T, species=[ID], res_width=True)

            x = np.array([[1, 0, 0, 0]], dtype=float)
            sigma = np.array([[1e6/hrg.density(), 0, 0, 0]])
            v = np.zeros((1, 3))
            surface = frzout.Surface(x, sigma, v)

            parts = frzout.sample(surface, hrg)
            m = np.sqrt(np.inner(parts['p']**2, [1, -1, -1, -1]))

            ax.hist(m, bins=64, normed=True, histtype='step', label=name)

        ax.set_xlim(0, 2)
        ax.set_xlabel('Mass [GeV]')
        ax.set_ylabel('Probability')
        ax.set_yticklabels([])

        ax.legend(loc='upper left')


@section
def equation_of_state(axes):
    """
    Comparison of thermodynamic quantities from phase-space integrals (grey
    dashed lines) to averages over sampled particles (solid colored lines).

    """
    with axes() as ax:
        volume = 1e6
        x = np.array([[1, 0, 0, 0]], dtype=float)
        sigma = np.array([[volume, 0, 0, 0]])
        v = np.zeros((1, 3))
        surface = frzout.Surface(x, sigma, v)

        def eos_quantities(T):
            hrg = frzout.HRG(T, res_width=False)
            parts = frzout.sample(surface, hrg)
            E = parts['p'][:, 0]
            psq = (parts['p'][:, 1:]**2).sum(axis=1)

            T3 = (T/hbarc)**3
            T4 = T * T3

            return [
                (hrg.density()/T3, parts.size/volume/T3),
                (hrg.energy_density()/T4, E.sum()/volume/T4),
                (3*hrg.pressure()/T4, 3*(psq/(3*E)).sum()/volume/T4),
            ]

        T = np.linspace(100, 180, 20)/1000

        for quantity, label in zip(
                np.array([eos_quantities(t) for t in T]).transpose(1, 2, 0),
                ['$n/T^3$', '$\epsilon/T^4$', '$3p/T^4$']
        ):
            ax.plot(T, quantity[1], label=label)
            ax.plot(T, quantity[0], color=default_color, ls='dashed')

        ax.set_xlabel('Temperature [GeV]')
        ax.legend(loc='upper left')
