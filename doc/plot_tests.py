# -*- coding: utf-8 -*-

import glob
import inspect
import os
from contextlib import contextmanager

import numpy as np
import matplotlib.pyplot as plt
from scipy import special
from scipy import stats
from sphinx.util import console

import frzout


sections = []


def section(function):
    sections.append(function)
    return function


def main(app):
    srcdir = app.builder.srcdir
    testsdir = os.path.join(app.config.html_static_path[0], 'tests')

    app.info(console.bold('generating test plots...'), nonl=True)

    # skip if all generated plot files are newer than this file
    plot_files = glob.glob(os.path.join(srcdir, testsdir, '*', '*.png'))
    if plot_files and all(
            os.path.getmtime(f) > os.path.getmtime(__file__)
            for f in plot_files
    ):
        app.info(' all up to date')
        return

    app.info()

    with open(os.path.join(srcdir, 'tests.rst'), 'w') as rst_file:
        rst_file.write(
            'Tests\n'
            '=====\n'
            'This page is automatically generated by '
            '`{basename} <https://github.com/{github_user}/{github_repo}'
            '/blob/master/doc/{basename}>`_ in the frzout repository.\n\n'
            'Each plot compares observables computed from the sampler '
            '(colored lines) to expected results (dark grey lines).\n'
            .format(
                basename=os.path.basename(__file__),
                **app.config.html_context
            )
        )

        for section in sections:
            title = section.__name__.replace('_', ' ').capitalize()
            app.info('  ' + title)
            rst_file.write(
                '\n{}\n{}\n{}\n'
                .format(title, '-'*len(title), inspect.getdoc(section))
            )

            reldir = os.path.join(testsdir, section.__name__)
            absdir = os.path.join(srcdir, reldir)
            os.makedirs(absdir, exist_ok=True)

            @contextmanager
            def axes(subsec=None, caption=None):
                if subsec:
                    app.info('    ' + subsec)
                    rst_file.write(
                        '\n{}\n{}'.format(subsec, '~'*len(subsec))
                    )
                if caption:
                    rst_file.write('\n{}\n'.format(caption))
                filename = '{:03d}.png'.format(axes.n)
                rst_file.write(
                    '\n.. image:: {0}\n   :target: {0}\n'
                    .format(os.path.join(reldir, filename))
                )
                yield plt.axes()
                plt.savefig(os.path.join(absdir, filename))
                plt.close()
                axes.n += 1

            axes.n = 0

            section(axes)


def setup(app):
    app.connect('builder-inited', main)


default_color = '#404040'
color_cycle = [
    getattr(plt.cm, c)(.8) for c in
    ['Blues', 'Greens', 'Oranges', 'Purples']
]
font_size = 16

plt.rcdefaults()
plt.rcParams.update({
    'figure.figsize': (10, 6.18),
    'figure.dpi': 200,
    'figure.autolayout': True,
    'font.family': ['Lato'],
    'font.size': font_size,
    'legend.fontsize': font_size,
    'axes.labelsize': font_size,
    'axes.titlesize': font_size,
    'xtick.labelsize': font_size - 2,
    'ytick.labelsize': font_size - 2,
    'lines.linewidth': 1.25,
    'lines.markeredgewidth': .1,
    'patch.linewidth': 1.25,
    'axes.prop_cycle': plt.cycler('color', color_cycle),
    'axes.grid': True,
    'axes.axisbelow': True,
    'axes.facecolor': '#eaeaf2',
    'axes.linewidth': 0,
    'grid.linestyle': '-',
    'grid.linewidth': 1,
    'grid.color': '#fcfcfc',
    'savefig.facecolor': '#fcfcfc',
    'xtick.major.size': 0,
    'ytick.major.size': 0,
    'xtick.minor.size': 0,
    'ytick.minor.size': 0,
    'xtick.major.pad': 7,
    'ytick.major.pad': 7,
    'text.color': default_color,
    'axes.edgecolor': default_color,
    'axes.labelcolor': default_color,
    'xtick.color': default_color,
    'ytick.color': default_color,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
})


id_parts = [
    (211, r'$\pi^\pm$'),
    (321, r'$K^\pm$'),
    (2212, r'$p \bar p$'),
]

hbarc = 0.1973269788


@section
def stationary_box(axes):
    """
    A single boost-invariant volume element with zero flow velocity.
    This is a rudimentary test case with easily-calculated observables.

    """
    volume = 3000.
    tau = 1.
    T = .15
    ymax = np.random.uniform(.5, .8)

    info = [frzout.species_dict[i] for (i, _) in id_parts]
    m = np.array([i['mass'] for i in info])
    g = np.array([i['degen'] for i in info])
    sign = np.array([-1 if i['boson'] else 1 for i in info])

    n = np.arange(1, 10)
    densities = g * m*m*T / (2*np.pi**2*hbarc**3) * (
        np.power.outer(-sign, n-1)/n *
        special.kn(2, np.outer(m, n)/T)
    ).sum(axis=1)
    yields = 2*ymax * volume * densities

    x = np.array([[tau, 0, 0]])
    sigma = np.array([[volume/tau, 0, 0]])
    v = np.zeros((1, 2))

    sampler = frzout.Sampler(x, sigma, v, T, ymax=ymax)

    nsamples = 1000
    samples = list(sampler.iter_samples(nsamples))
    parts = np.concatenate(samples).view(np.recarray)

    abs_ID = np.abs(parts.ID)
    E, px, py, pz = parts.p.T

    with axes(
            'Multiplicity distributions',
            'These are histograms of particle counts from many oversamples. '
            'Production of each species should be Poissonian:'
    ) as ax:
        for (i, label), N in zip(id_parts, yields):
            dist = stats.poisson(N)
            x = np.arange(*dist.ppf([.001, .999]).astype(int))
            ax.plot(x, dist.pmf(x), color=default_color)
            ax.hist([np.count_nonzero(s.ID == i) for s in samples],
                    bins=20, normed=True, histtype='step',
                    label=label.replace(r'\pm', '+').replace(r' \bar p', ''))

        ax.set_xlabel('Number of particles')
        ax.set_ylabel('Probability')
        ax.set_yticklabels([])
        ax.legend()

    with axes(caption=(
            'Overall particle production (all species) '
            'should also be Poissonian:'
    )) as ax:
        N = np.array([s.size for s in samples])
        dist = stats.poisson(sampler.navg)
        x = np.arange(*dist.ppf([.001, .999]).astype(int))
        ax.plot(x, dist.pmf(x), color=default_color)
        ax.hist(N, bins=30, normed=True,
                histtype='step', color=color_cycle[-1])
        ax.set_xlabel('Number of particles')
        ax.set_ylabel('Probability')
        ax.set_yticklabels([])

    with axes('Transverse momentum', 'Spectra are perfectly thermal:') as ax:
        pT = np.sqrt(px*px + py*py)
        pT_plot = np.linspace(0, 3, 1000)
        for k, (i, label) in enumerate(id_parts):
            mT = np.sqrt(frzout.species_dict[i]['mass']**2 + pT_plot**2)
            dN_dpT = 2*(
                volume * frzout.species_dict[i]['degen'] * (
                    np.outer(
                        2*mT,
                        (1 if frzout.species_dict[i]['boson'] else -1)**(n-1)
                    ) * special.k1(np.outer(mT, n)/T)
                ).sum(axis=1) / (2*np.pi*hbarc)**3
            )
            scale = 10**(-2*k)
            ax.plot(pT_plot, dN_dpT*scale, color=default_color)
            pT_ = pT[abs_ID == i]
            bins = np.linspace(0, pT_.max(), 50)
            ax.hist(
                pT_, bins=bins,
                weights=bins.size/bins.ptp()*scale/(
                    2*np.pi*pT_*2*ymax*nsamples),
                histtype='step', log=True,
                label=r'{} $({{\times}}10^{{{:d}}})$'.format(label, -2*k)
            )

        ax.set_xlabel('$p_T\ [\mathrm{GeV}]$')
        ax.set_ylabel('$1/2\pi p_T \: dN/dp_T\,dy\ [\mathrm{GeV}^{-2}]$')
        ax.yaxis.get_major_locator().base(100)
        ax.legend()

    with axes('Rapidity', '`dN/dy` should be flat:') as ax:
        y = .5*np.log((E + pz)/(E - pz))
        nbins = 50
        for (i, label), N in zip(id_parts, yields):
            ax.plot([-ymax, ymax], [2*N]*2, color=default_color)
            y_ = y[abs_ID == i]
            ax.hist(y_, bins=nbins, weights=np.full_like(y_, nbins/nsamples),
                    histtype='step', log=True, label=label)

        ax.set_xlabel('$y$')
        ax.set_ylabel('$dN/dy$')
        ax.legend(loc='lower center', ncol=len(id_parts))

    with axes('Azimuthal angle', '`dN/d\phi` should be flat:') as ax:
        phi = np.arctan2(py, px)
        nbins = 50
        for (i, label), N in zip(id_parts, yields):
            ax.plot([-np.pi, np.pi], [2*N]*2, color=default_color)
            phi_ = phi[abs_ID == i]
            ax.hist(phi_, bins=nbins,
                    weights=np.full_like(phi_, nbins/nsamples),
                    histtype='step', log=True, label=label)

        ax.set_xlim(-np.pi, np.pi)
        ax.set_xlabel('$\phi$')
        ax.set_ylabel('$dN/d\phi$')
        ax.legend(loc='lower center', ncol=len(id_parts))


@section
def realistic_surface(axes):
    """
    Event-by-event 2D hypersurface.

    """
    pass
